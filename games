import pygame
import random
import math
from pygame import gfxdraw

# Initialize Pygame
pygame.init()

# Game Constants
WIDTH, HEIGHT = 800, 600
CELL_SIZE = 24
FPS = 60
GRID_COLS, GRID_ROWS = WIDTH//CELL_SIZE, HEIGHT//CELL_SIZE

# Modern Color Palette
COLORS = {
    "dark": (30, 35, 40),
    "grid": (50, 55, 60),
    "snake_head": (100, 230, 150),
    "snake_body": (80, 180, 120),
    "food": (250, 90, 90),
    "text": (240, 240, 240),
    "particle": (250, 150, 100)
}

class Snake:
    def __init__(self):
        self.reset()
        self.particles = []
        
    def reset(self):
        self.body = [(GRID_COLS//2, GRID_ROWS//2)]
        self.direction = (1, 0)
        self.next_direction = (1, 0)
        self.grow = False
        self.speed = 8  # Moves per second
        self.move_timer = 0
        self.alive = True
        
    def update(self, dt):
        self.move_timer += dt
        move_interval = 1000 / self.speed  # ms per move
        
        if self.move_timer >= move_interval:
            self.move_timer = 0
            self.direction = self.next_direction
            
            # Move head
            head_x, head_y = self.body[0]
            new_head = (
                (head_x + self.direction[0]) % GRID_COLS,
                (head_y + self.direction[1]) % GRID_ROWS
            )
            
            # Check collision with self
            if new_head in self.body:
                self.alive = False
                self.create_particles(new_head)
                return False
            
            self.body.insert(0, new_head)
            
            if not self.grow:
                self.body.pop()
            else:
                self.grow = False
                self.create_particles(new_head)
                
        return True
    
    def create_particles(self, pos):
        for _ in range(15):
            angle = random.uniform(0, math.pi*2)
            speed = random.uniform(0.5, 2)
            self.particles.append({
                'pos': [pos[0]*CELL_SIZE + CELL_SIZE//2, pos[1]*CELL_SIZE + CELL_SIZE//2],
                'vel': [math.cos(angle)*speed, math.sin(angle)*speed],
                'life': random.randint(30, 60),
                'size': random.randint(2, 4)
            })
    
    def update_particles(self):
        for p in self.particles[:]:
            p['pos'][0] += p['vel'][0]
            p['pos'][1] += p['vel'][1]
            p['life'] -= 1
            if p['life'] <= 0:
                self.particles.remove(p)
    
    def change_direction(self, new_dir):
        # Prevent 180-degree turns
        if (new_dir[0] * -1, new_dir[1] * -1) != self.direction:
            self.next_direction = new_dir

class Food:
    def __init__(self):
        self.position = (0, 0)
        self.spawn()
        self.pulse = 0
        
    def spawn(self):
        self.position = (
            random.randint(0, GRID_COLS-1),
            random.randint(0, GRID_ROWS-1)
        )
        self.pulse = 0
        
    def update(self):
        self.pulse = (self.pulse + 0.05) % (math.pi*2)

class Game:
    def __init__(self):
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        pygame.display.set_caption("Modern Snake")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.SysFont('Arial', 24, bold=True)
        self.small_font = pygame.font.SysFont('Arial', 16)
        
        self.snake = Snake()
        self.food = Food()
        self.score = 0
        self.high_score = 0
        self.game_active = True
        self.game_over = False
        
    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            
            if event.type == pygame.KEYDOWN:
                if self.game_over and event.key == pygame.K_SPACE:
                    self.reset_game()
                elif self.game_active:
                    if event.key == pygame.K_UP:
                        self.snake.change_direction((0, -1))
                    elif event.key == pygame.K_DOWN:
                        self.snake.change_direction((0, 1))
                    elif event.key == pygame.K_LEFT:
                        self.snake.change_direction((-1, 0))
                    elif event.key == pygame.K_RIGHT:
                        self.snake.change_direction((1, 0))
        
        return True
    
    def update(self, dt):
        if not self.game_active:
            return
            
        if not self.snake.update(dt):
            self.game_over = True
            self.game_active = False
            self.high_score = max(self.score, self.high_score)
        
        self.snake.update_particles()
        self.food.update()
        
        # Check food collision
        if self.snake.body[0] == self.food.position:
            self.snake.grow = True
            self.score += 10
            self.food.spawn()
            # Ensure food doesn't spawn on snake
            while self.food.position in self.snake.body:
                self.food.spawn()
    
    def draw(self):
        # Dark background
        self.screen.fill(COLORS["dark"])
        
        # Draw grid lines
        for x in range(0, WIDTH, CELL_SIZE):
            pygame.draw.line(self.screen, COLORS["grid"], (x, 0), (x, HEIGHT), 1)
        for y in range(0, HEIGHT, CELL_SIZE):
            pygame.draw.line(self.screen, COLORS["grid"], (0, y), (WIDTH, y), 1)
        
        # Draw food with pulsing effect
        food_size = CELL_SIZE * (0.8 + 0.2 * math.sin(self.food.pulse))
        pygame.draw.circle(
            self.screen, COLORS["food"],
            (self.food.position[0]*CELL_SIZE + CELL_SIZE//2, 
             self.food.position[1]*CELL_SIZE + CELL_SIZE//2),
            food_size//2
        )
        
        # Draw snake
        for i, segment in enumerate(self.snake.body):
            x, y = segment
            pos_x, pos_y = x*CELL_SIZE, y*CELL_SIZE
            
            # Head is brighter
            color = COLORS["snake_head"] if i == 0 else COLORS["snake_body"]
            
            # Smooth rounded rectangles
            pygame.draw.rect(
                self.screen, color,
                (pos_x + 2, pos_y + 2, CELL_SIZE - 4, CELL_SIZE - 4),
                border_radius=4
            )
        
        # Draw particles
        for p in self.snake.particles:
            alpha = min(255, p['life'] * 4)
            color = (*COLORS["particle"], alpha)
            gfxdraw.filled_circle(
                self.screen, 
                int(p['pos'][0]), int(p['pos'][1]),
                p['size'], color
            )
        
        # Draw score
        score_text = self.font.render(f"Score: {self.score}", True, COLORS["text"])
        self.screen.blit(score_text, (20, 20))
        
        # Game over screen
        if self.game_over:
            overlay = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 180))
            self.screen.blit(overlay, (0, 0))
            
            game_over_text = self.font.render("GAME OVER", True, COLORS["food"])
            score_text = self.font.render(f"Final Score: {self.score}", True, COLORS["text"])
            restart_text = self.small_font.render("Press SPACE to restart", True, COLORS["text"])
            
            self.screen.blit(game_over_text, (WIDTH//2 - game_over_text.get_width()//2, HEIGHT//2 - 50))
            self.screen.blit(score_text, (WIDTH//2 - score_text.get_width()//2, HEIGHT//2))
            self.screen.blit(restart_text, (WIDTH//2 - restart_text.get_width()//2, HEIGHT//2 + 50))
        
        pygame.display.flip()
    
    def reset_game(self):
        self.snake.reset()
        self.food.spawn()
        self.score = 0
        self.game_active = True
        self.game_over = False
    
    def run(self):
        running = True
        last_time = pygame.time.get_ticks()
        
        while running:
            current_time = pygame.time.get_ticks()
            dt = current_time - last_time
            last_time = current_time
            
            running = self.handle_events()
            self.update(dt)
            self.draw()
            self.clock.tick(FPS)

if __name__ == "__main__":
    game = Game()
    game.run()