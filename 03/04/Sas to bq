import re
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s:%(message)s')

# Function to convert SAS variable declarations to BigQuery SQL
def convert_var_declaration(sas_code):
    match = re.search(r'data\s+(\w+);', sas_code, re.IGNORECASE)
    if match:
        table_name = match.group(1)
        logging.info(f"Converting data step to CREATE TABLE: {table_name}")
        return f"CREATE TABLE {table_name} AS"
    return ""

# Function to convert SAS set statements to BigQuery SQL
def convert_set_statement(sas_code):
    match = re.search(r'set\s+(\w+)\.(\w+)', sas_code, re.IGNORECASE)
    if match:
        libname, dataset = match.group(1), match.group(2)
        logging.info(f"Converting set statement to SELECT: {libname}.{dataset}")
        return f"SELECT * FROM {libname}.{dataset}"
    return ""

# Function to convert KEEP, DROP, and RENAME statements
def convert_keep_drop_rename(sas_code):
    # Convert KEEP
    keep_pattern = re.compile(r'\(keep\s*=\s*\((.*?)\)\)', re.IGNORECASE)
    sas_code = keep_pattern.sub(lambda m: f"SELECT {m.group(1)}", sas_code)
    
    # Convert DROP
    drop_pattern = re.compile(r'\(drop\s*=\s*\((.*?)\)\)', re.IGNORECASE)
    sas_code = drop_pattern.sub(lambda m: f"SELECT * EXCEPT ({m.group(1)})", sas_code)
    
    # Convert RENAME
    rename_pattern = re.compile(r'\(rename\s*=\s*\((.*?)\)\)', re.IGNORECASE)
    sas_code = rename_pattern.sub(lambda m: ', '.join(f'{old} AS {new}' for old, new in re.findall(r'(\w+)\s*=\s*(\w+)', m.group(1))), sas_code)
    
    logging.info("Converting KEEP, DROP, and RENAME statements")
    return sas_code

# Function to convert if-then-else statements
def convert_if_else(sas_code):
    sas_code = re.sub(r'if\s+(.+?)\s+then\s+(.+?);', r'CASE WHEN \1 THEN \2', sas_code, flags=re.IGNORECASE)
    sas_code = re.sub(r'else\s+(.+?);', r'ELSE \1 END', sas_code, flags=re.IGNORECASE)
    logging.info("Converting if-then-else statements")
    return sas_code

# Function to convert SAS functions to BigQuery SQL
def convert_sas_functions(sas_code):
    sas_to_bq_functions = {
        'substr': 'SUBSTR',
        'trim': 'TRIM',
        'left': 'LEFT',
        'right': 'RIGHT',
        'upcase': 'UPPER',
        'lowcase': 'LOWER',
        'int': 'CAST',
        'put': 'CAST',
        'mean': 'AVG',
        'sum': 'SUM',
        'n': 'COUNT',
        'max': 'MAX',
        'min': 'MIN',
        'log': 'LOG',
        'exp': 'EXP'
    }
    for sas_func, bq_func in sas_to_bq_functions.items():
        sas_code = re.sub(r'\b' + sas_func + r'\b', bq_func, sas_code, flags=re.IGNORECASE)
    logging.info("Converting SAS functions to BigQuery functions")
    return sas_code

# Function to convert proc sql to BigQuery SQL
def convert_proc_sql(sas_code):
    proc_sql_pattern = re.compile(r'proc\s+sql;\s*(.*?)\s*quit;', re.IGNORECASE | re.DOTALL)
    match = proc_sql_pattern.search(sas_code)
    if match:
        sql_statements = match.group(1).strip()
        sql_statements = convert_sas_functions(sql_statements)
        sql_statements = convert_keep_drop_rename(sql_statements)
        logging.info("Converting proc sql block")
        return sql_statements
    return ""

# Function to convert proc freq and proc means
def convert_proc_freq_means(sas_code):
    proc_freq_pattern = re.compile(r'proc\s+freq\s+data=(\w+);(.*?)(run;)', re.IGNORECASE | re.DOTALL)
    proc_means_pattern = re.compile(r'proc\s+means\s+data=(\w+);(.*?)(run;)', re.IGNORECASE | re.DOTALL)
    
    freq_match = proc_freq_pattern.search(sas_code)
    means_match = proc_means_pattern.search(sas_code)
    
    if freq_match:
        dataset = freq_match.group(1)
        tables = freq_match.group(2)
        variables = re.findall(r'tables\s+(\w+);', tables, re.IGNORECASE)
        columns = ', '.join(variables)
        logging.info(f"Converting proc freq for dataset: {dataset}")
        return f"SELECT {columns}, COUNT(*) AS freq FROM {dataset} GROUP BY {columns}"
    
    if means_match:
        dataset = means_match.group(1)
        vars_block = means_match.group(2)
        variables = re.findall(r'var\s+(\w+);', vars_block, re.IGNORECASE)
        columns = ', '.join(variables)
        logging.info(f"Converting proc means for dataset: {dataset}")
        return f"SELECT {columns}, AVG({columns}) AS mean_value, SUM({columns}) AS sum_value, STDDEV({columns}) AS stddev_value FROM {dataset} GROUP BY {columns}"
    
    return ""

# Function to handle SAS macros
def convert_macros(sas_code):
    macros = re.findall(r'%macro\s+(\w+);(.*?)%mend;', sas_code, re.IGNORECASE | re.DOTALL)
    for macro_name, macro_body in macros:
        converted_macro_body = convert_sas_to_bigquery(macro_body)
        sas_code = sas_code.replace(f"%macro {macro_name};{macro_body}%mend;", f"-- Macro: {macro_name}\n{converted_macro_body}\n-- End Macro: {macro_name}")
        logging.info(f"Converting macro: {macro_name}")
    return sas_code

# Function to convert proc print to BigQuery
def convert_proc_print(sas_code):
    proc_print_pattern = re.compile(r'proc\s+print\s+data=(\w+);(.*?)(run;)', re.IGNORECASE | re.DOTALL)
    match = proc_print_pattern.search(sas_code)
    
    if match:
        dataset = match.group(1)
        options = match.group(2).strip()
        columns = re.findall(r'var\s+([\w\s]+);', options, re.IGNORECASE)
        columns = ', '.join([col.strip() for col in columns[0].split()]) if columns else '*'
        logging.info(f"Converting proc print for dataset: {dataset}")
        return f"SELECT {columns} FROM {dataset}"
    return ""

# Function to convert proc sort to BigQuery
def convert_proc_sort(sas_code):
    proc_sort_pattern = re.compile(r'proc\s+sort\s+data=(\w+);(.*?)(run;)', re.IGNORECASE | re.DOTALL)
    match = proc_sort_pattern.search(sas_code)
    
    if match:
        dataset = match.group(1)
        options = match.group(2).strip()
        by_clause = re.findall(r'by\s+([\w\s]+);', options, re.IGNORECASE)
        by_columns = ', '.join([col.strip() for col in by_clause[0].split()]) if by_clause else ''
        logging.info(f"Converting proc sort for dataset: {dataset}")
        return f"SELECT * FROM {dataset} ORDER BY {by_columns}"
    return ""

# Function to handle nested queries
def handle_nested_queries(sas_code):
    nested_query_pattern = re.compile(r'\(\s*select\s+(.*?)\s*from\s+(.*?)\)', re.IGNORECASE | re.DOTALL)
    sas_code = nested_query_pattern.sub(r'(\1 FROM \2)', sas_code)
    logging.info("Handling nested queries")
    return sas_code

# Function to handle advanced joins
def handle_advanced_joins(sas_code):
    join_pattern = re.compile(r'(\w+)\s+join\s+(\w+)\s+on\s+(\w+\.\w+)\s*=\s*(\w+\.\w+)', re.IGNORECASE)
    sas_code = join_pattern.sub(r'\1 JOIN \2 ON \3 = \4', sas_code)
    logging.info("Handling advanced joins")
    return sas_code

# Function to convert proc univariate to BigQuery
def convert_proc_univariate(sas_code):
    proc_univariate_pattern = re.compile(r'proc\s+univariate\s+data=(\w+);(.*?)(run;)', re.IGNORECASE | re.DOTALL)
    match = proc_univariate_pattern.search(sas_code)
    
    if match:
        dataset = match.group(1)
        vars_block = match.group(2)
        variables = re.findall(r'var\s+(\w+);', vars_block, re.IGNORECASE)
        columns = ', '.join(variables)
        logging.info(f"Converting proc univariate for dataset: {dataset}")
        return f"SELECT {columns}, AVG({columns}) AS mean_value, STDDEV({columns}) AS stddev_value, MIN({columns}) AS min_value, MAX({columns}) AS max_value FROM {dataset} GROUP BY {columns}"
    return ""

# Function to convert proc format to BigQuery
def convert_proc_format(sas_code):
    proc_format_pattern = re.compile(r'proc\s+format\s+(.*?);', re.IGNORECASE | re.DOTALL)
    match = proc_format_pattern.search(sas_code)
    
    if match:
        format_block = match.group(1)
        formats = re.findall(r'value\s+(\w+)\s+(.*?);', format_block, re.IGNORECASE | re.DOTALL)
        converted_formats = []
        for format_name, format_body in formats:
            values = re.findall(r'(\d+)\s*=\s*"(.*?)"', format_body, re.IGNORECASE)
            for value, label in values:
                converted_formats.append(f"WHEN {value} THEN '{label}'")
        logging.info("Converting proc format")
        return f"CASE {' '.join(converted_formats)} END"
    return ""

# Function to convert proc report to BigQuery
def convert_proc_report(sas_code):
    proc_report_pattern = re.compile(r'proc\s+report\s+data=(\w+);(.*?)(run;)', re.IGNORECASE | re.DOTALL)
    match = proc_report_pattern.search(sas_code)
    
    if match:
        dataset = match.group(1)
        columns_block = match.group(2)
        columns = re.findall(r'column\s+([\w\s]+);', columns_block, re.IGNORECASE)
        columns = ', '.join([col.strip() for col in columns[0].split()]) if columns else '*'
        logging.info(f"Converting proc report for dataset: {dataset}")
        return f"SELECT {columns} FROM {dataset}"
    return ""

# Function to convert proc transpose to BigQuery
def convert_proc_transpose(sas_code):
    proc_transpose_pattern = re.compile(r'proc\s+transpose\s+data=(\w+);(.*?)(run;)', re.IGNORECASE | re.DOTALL)
    match = proc_transpose_pattern.search(sas_code)
    
    if match:
        dataset = match.group(1)
        options = match.group(2).strip()
        id_var = re.findall(r'id\s+(\w+);', options, re.IGNORECASE)
        by_var = re.findall(r'by\s+(\w+);', options, re.IGNORECASE)
        var_var = re.findall(r'var\s+(\w+);', options, re.IGNORECASE)
        id_var = id_var[0] if id_var else ''
        by_var = by_var[0] if by_var else ''
        var_var = var_var[0] if var_var else ''
        logging.info(f"Converting proc transpose for dataset: {dataset}")
        return f"SELECT {id_var}, {by_var}, {var_var} FROM {dataset} PIVOT (MAX({var_var}) FOR {id_var} IN ({var_var}))"
    return ""

# Main function to convert SAS code to BigQuery SQL
def convert_sas_to_bigquery(sas_code):
    bigquery_code = []
    lines = sas_code.split('\n')
    
    in_proc_sql = False
    proc_sql_buffer = []
    
    # Handle macros
    sas_code = convert_macros(sas_code)

    for line in lines:
        line = line.strip()
        
        # Check if we're within a proc sql block
        if line.lower().startswith("proc sql"):
            in_proc_sql = True
            proc_sql_buffer.append(line)
            continue
        if in_proc_sql:
            proc_sql_buffer.append(line)
            if line.lower().startswith("quit;"):
                proc_sql_code = ' '.join(proc_sql_buffer)
                bigquery_code.append(convert_proc_sql(proc_sql_code))
                in_proc_sql = False
                proc_sql_buffer = []
            continue

        if line.lower().startswith("data"):
            bigquery_code.append(convert_var_declaration(line))
        elif line.lower().startswith("set"):
            bigquery_code.append(convert_set_statement(line))
        elif line.lower().startswith("if"):
            bigquery_code.append(convert_if_else(line))
        elif line.lower().startswith("proc freq") or line.lower().startswith("proc means"):
            bigquery_code.append(convert_proc_freq_means(line))
        elif line.lower().startswith("proc print"):
            bigquery_code.append(convert_proc_print(line))
        elif line.lower().startswith("proc sort"):
            bigquery_code.append(convert_proc_sort(line))
        elif line.lower().startswith("proc univariate"):
            bigquery_code.append(convert_proc_univariate(line))
        elif line.lower().startswith("proc format"):
            bigquery_code.append(convert_proc_format(line))
        elif line.lower().startswith("proc report"):
            bigquery_code.append(convert_proc_report(line))
        elif line.lower().startswith("proc transpose"):
            bigquery_code.append(convert_proc_transpose(line))
        else:
            bigquery_code.append(convert_sas_functions(line))

    # Join the converted lines into the final BigQuery SQL script
    bigquery_sql = '\n'.join(bigquery_code).rstrip(',')
    bigquery_sql = handle_nested_queries(bigquery_sql)
    bigquery_sql = handle_advanced_joins(bigquery_sql)
    return bigquery_sql

# Complex SAS code for testing
sas_code = """
%macro complex_macro;
    /* Data Step with KEEP, DROP, and RENAME */
    data work.new_dataset (keep=id age group salary rename=(age=years));
        set libname.old_dataset (drop=gender);
        /* Conditional Logic */
        if years > 30 then group = 'A';
        else if years > 20 then group = 'B';
        else group = 'C';
        
        /* Creating new variables */
        length category $10;
        if salary > 50000 then category = 'High';
        else if salary > 30000 then category = 'Medium';
        else category = 'Low';
    run;
    
    /* Proc SQL with Joins and Subqueries */
    proc sql;
        create table work.joined as
        select a.id, a.years, a.salary, b.department, 
               (select max(salary) from libname.old_dataset where department = b.department) as max_dept_salary
        from work.new_dataset as a
        left join libname.departments as b
        on a.id = b.id;
    quit;
    
    /* Proc FREQ */
    proc freq data=work.new_dataset;
        tables group category / missing;
    run;
    
    /* Proc MEANS */
    proc means data=work.new_dataset n mean std min max;
        var salary years;
    run;
    
    /* Proc PRINT */
    proc print data=work.new_dataset;
        var id years salary category;
    run;
    
    /* Proc SORT */
    proc sort data=work.new_dataset out=work.sorted_dataset;
        by category descending salary;
    run;
    
    /* Proc UNIVARIATE */
    proc univariate data=work.new_dataset;
        var salary years;
    run;
    
    /* Proc FORMAT */
    proc format;
        value $category_fmt
            'High' = 'High Salary'
            'Medium' = 'Medium Salary'
            'Low' = 'Low Salary';
        value age_fmt
            1 - 20 = 'Young'
            21 - 30 = 'Adult'
            31 - high = 'Senior';
    run;
    
    /* Proc REPORT */
    proc report data=work.new_dataset;
        column id years salary category;
        define id / group;
        define years / analysis;
        define salary / analysis sum;
        define category / display;
    run;
    
    /* Proc TRANSPOSE */
    proc transpose data=work.new_dataset out=work.transposed_dataset;
        by id;
        id category;
        var salary;
    run;
%mend;

%complex_macro;
"""

# Convert SAS to BigQuery
bigquery_code = convert_sas_to_bigquery(sas_code)
print(bigquery_code)
```

### Explanation

1. **Macro Handling**: The script handles macros by expanding them and then converting the expanded code.
2. **Data Step**: Handles `KEEP`, `DROP`, and `RENAME` statements, and conditional logic.
3. **Proc SQL**: Converts SQL statements with joins and subqueries.
4. **Procedures**: Converts `proc freq`, `proc means`, `proc print`, `proc sort`, `proc univariate`, `proc format`, `proc report`, and `proc transpose`.
5. **SAS Functions**: Maps common SAS functions to their BigQuery equivalents.
6. **Conditional Logic**: Converts complex if-then-else structures.

This script should cover a wide range of SAS constructs and provide a comprehensive conversion to BigQuery SQL.
